# 5. 虚拟机

容器经常与虚拟机（VMs）进行比较，特别是在它们提供的隔离方面。如果我们比较了解虚拟机运作原理，有助于推断它们与容器之间的区别。当我们希望评估应用程序在容器中或不同虚拟机中运行时的安全边界时，这将特别有用。在讨论容器相对于虚拟机安全性的优点时，了解它们与虚拟机的区别是一个有用的工具。

实际上，这并非是一个非黑即白的区别。正如您将在第8章中看到的那样，有几种沙箱工具可以加强容器周围的隔离边界，使其更类似于虚拟机。如果您想了解这些方法的安全优缺点，最好从彻底理解虚拟机和“普通”容器之间的区别开始。

根本的区别在于虚拟机运行整个操作系统的副本，包括其内核，而容器共享主机机器的内核。为了理解这意味着什么，我们需要了虚拟机监视器（VMM）创建和管理虚拟机的。让我们开始为此做铺垫，思考计算机启动时发生了什么。

想象一台物理服务器。它具有CPU、内存和网络接口。当我们首次启动该机器时，运行一个称为BIOS或者基本输入输出系统的初始程序。它扫描可用内存量，识别网络接口，并检测任何其他设备，如显示器、键盘、连接的存储设备等。

在实践中，如今许多这方面的功能已经被UEFI（统一可扩展固件接口）取代，但为了论证的目的，我们可以将其视为现代版的BIOS。

 硬件枚举完成后，系统运行一个引导加载程序，它加载并运行操作系统的内核代码。操作系统可以是Linux、Windows或其它某个操作系统。正如在第2章中所讲述的，内核代码的运行权限级别比应用程序代码更高。这也使其能够与内存、网络接口等进行交互，而在用户空间运行的应用程序则不能直接执行这些操作。

在x86处理器上，特权级别被组织成环，Ring 0是最高特权级别，Ring 3是最低特权级别。在大多数常规设置的操作系统中（不包含虚拟机），内核在Ring 0运行，用户空间代码在Ring 3运行，如图5-1所示。

![image-20240229212616757](https://gitee.com/xw1150/m2sec_image/raw/master/img/202402292126930.png)

图5-1 特权环

内核代码（就像任何代码一样）以机器代码指令的形式在CPU上运行，这些指令可以包括用于访问内存、启动CPU线程等的特权指令。内核初始化期间可能发生和将要发生的一切细节超出了本书的范围，但基本上目标是挂载根文件系统、设置网络并启动任何系统守护进程。 （如果想深入了解，GitHub上有很多关于Linux内核的不错的内容，包括引导过程。）

一旦内核完成自己的初始化，它就可以开始在用户空间运行程序。内核负责管理用户空间程序所需的一切。它启动、管理和调度这些程序运行的 CPU 线程，并通过自己的数据结构（代表线程）跟踪这些线程。内核功能的一个重要方面是内存管理。内核为每个进程分配内存块，并确保进程无法访问彼此的内存块。

## 进入虚拟机监控器（VMM） 

正如上面所提到的，在常规设置中，内核直接管理计算机的资源。在虚拟机环境中，VMM负责第一层资源管理，将资源分割并分配给虚拟机。每个虚拟机都拥有自己的内核。 对于VMM管理的每个虚拟机，VMM为它们分配一些内存和CPU资源，设置一些虚拟网络接口和其他虚拟设备，并启动一个具有对这些资源访问权限的客户内核。

在常规服务器中，BIOS向内核提供机器上可用资源的详细信息；在虚拟机情况下，VMM将这些资源划分并仅向每个客户内核提供其被访问的子集的详细信息。从客户操作系统的角度来看，它认为自己直接访问物理内存和设备，但实际上它正在访问VMM提供的抽象层。

VMM负责确保客户操作系统及其应用程序不能越过其被分配的资源边界。例如，客户操作系统被分配了主机机器上的一段内存范围。如果客户以某种方式尝试访问该范围之外的内存，这是被禁止的。 

VMM有两种主要形式，通常分别称为Type 1和Type 2。当然，它们之间存在一些灰色地带！

## Type1 VMMs 或者 Hypervisors

在常规系统中，引导加载程序运行操作系统内核，如Linux或Windows。在纯Type 1虚拟机环境中，专用的内核级VMM程序取代了操作系统内核的运行。 Type 1 VMMs也被称为hypervisors，其中的例子包括Hyper-V、Xen和ESX/ESXi。正如图5-2所示，hypervisor直接在硬件上（或称为“裸机”）运行，其下方没有操作系统。

![image-20240301222333610](https://gitee.com/xw1150/m2sec_image/raw/master/img/202403052019113.png)

图5-2. Type 1 VMMs，也称为hypervisor

在说“内核级”时，本文指的是hypervisor在Ring 0上运行。（嗯，直到我们在本章后面考虑硬件虚拟化之前都是这样，但现在让我们假设是Ring 0。）客户操作系统内核在Ring 1上运行，如图5-3所示，这意味着它的特权比hypervisor低。	

![image-20240301222525757](https://gitee.com/xw1150/m2sec_image/raw/master/img/202403012225862.png)

图5-3. 在hypervisor下使用的特权环

## **Type 2 VMM**

当我们在笔记本电脑或台式机上（比如通过VirtualBox等工具）运行虚拟机时，它们被称为“hosted”或Type 2虚拟机。我们的笔记本电脑可能运行着macOS，也就是说它运行着macOS内核。我们安装VirtualBox作为一个独立的应用程序，然后它管理着与我们的主机操作系统共存的客户虚拟机。这些客户虚拟机可以运行Linux或Windows等操作系统。图5-4显示了客户操作系统和主机操作系统是如何共存的

![image-20240301222921584](https://gitee.com/xw1150/m2sec_image/raw/master/img/202403012229697.png)

 图5-4. Type2虚拟机监视器

请思考一下，想一想在macOS中运行Linux意味着什么。从定义上来说，这意味着必须有一个Linux内核，并且该内核必须与主机的macOS内核不同。

 VMM应用程序具有用户空间组件，我们可以作为用户与之交互，但它还安装了特权组件，使其能够提供虚拟化。本章会在后文中详细讲解这是如何工作的。

除了VirtualBox之外，Type 2 VMMs的其他例子包括[Parallels](https://www.parallels.cn/)和[QEMU](https://en.m.wikipedia.org/wiki/QEMU)。

## 基于内核的虚拟机(KVM)

我承诺之间在于Type 1和Type 2之间会存在一些模糊的边界。在Type 1中，hypervisor 直接在裸机上运行；在Type 2中，虚拟机监视器在主机操作系统的用户空间运行。那么，如果我们在主机操作系统的内核中运行虚拟机管理器会怎样呢？

这一个名为KVM（Kernel-Based Virtual Machines）的Linux内核模块正在发生的情况，如图5-5所示。

![image-20240303181125299](https://gitee.com/xw1150/m2sec_image/raw/master/img/202403031811389.png)

图5-5. KVM


通常情况下，KVM被认为是一种Type 1 hypervisor ，因为客户操作系统无需经过主机操作系统，但我认为这种分类过于简化了。KVM通常与前文列举的Type 2 hypervisor 之一的QEMU（Quick Emulation）一起使用。QEMU会动态地将客户操作系统的系统调用转换为主机操作系统的系统调用。值得一提的是，QEMU可以利用KVM提供的硬件加速功能。

无论是Type 1、Type 2，还是介于两者之间，虚拟机监视器都使用类似的技术来实现虚拟化。这基本思想被称为“陷阱和模拟”（trap-and-emulate），但是x86处理器在实现这一思想时将会遇到一些挑战。

## 陷阱和模拟

有些CPU指令是特权指令，意味着它们只能在Ring 0中执行；如果尝试在更高的环级中执行它们，将引发一个陷阱（trap）。可以将陷阱视为应用软件中的异常，触发错误处理程序；陷阱将导致CPU调用Ring 0代码中的处理程序。

如果虚拟机监视器（VMM）运行在Ring 0，而客户操作系统内核代码以较低特权级运行，那么客户操作系统运行的特权指令可以调用VMM中的处理程序来模拟该指令。通过这种方式，VMM可以确保客户操作系统之间不能通过特权指令相互干扰


不幸的是，特权指令只是问题的一部分。能够影响计算机资源的CPU指令集被称为敏感指令。虚拟机监视器（VMM）需要代表客户操作系统处理这些指令，因为只有VMM才能真正了解计算机资源的情况。还有另一类敏感指令，当在Ring 0或较低特权级中执行时，其行为会有所不同。同样，VMM需要处理这些指令，因为客户操作系统的代码是在假定Ring 0行为的基础上编写的。

如果所有敏感指令都是特权指令，这将使VMM程序员的工作相对容易，因为他们只需为所有这些敏感指令编写陷阱处理程序。不幸的是，并非所有x86敏感指令也是特权指令，因此VMM需要使用不同的技术来处理它们。敏感但非特权指令被认为是“不可虚拟化”的。

## 处理不可虚拟化指令

- 二进制翻译： 一种选择是二进制翻译。虚拟机监视器（VMM）会实时检测和重写客户操作系统中的所有非特权敏感指令。这是一种复杂的方法，而较新的x86处理器支持硬件辅助虚拟化，以简化二进制翻译。
- 半虚拟化： 另一种选择是半虚拟化。与实时修改客户操作系统不同，半虚拟化会重写客户操作系统，以避免不可虚拟化指令集，实际上使其对超级管理程序进行系统调用。Xen hypervisor 就是使用此技术。
- 硬件虚拟化： 硬件虚拟化（例如Intel的VT-x）允许hypervisor 在新的、额外的特权级别中运行，称为VMX根模式，实际上相当于Ring -1。这允许虚拟机客户操作系统内核像主机操作系统一样以Ring 0（或VMX非根模式）的特权级别运。

<img src="https://gitee.com/xw1150/images/raw/master/img/202402251635725.png" alt="image-20240225163501649" style="float: left;">如果读者想深入了解虚拟化的工作原理，可以阅读[Keith Adams](https://www.vmware.com/pdf/asplos235_adams.pdf)和[Ole Agesen](https://www.vmware.com/pdf/asplos235_adams.pdf)的文章，他们描述了硬件增强如何提升性能。







现在已经了解了虚拟机是如何创建和管理的，让我们考虑不同进程或应用程序之间相互隔离意味着什么。

## 进程隔离和安全

确保应用程序之间安全隔离是主要的安全关注点。如果我的应用程序能够读取属于您的应用程序的内存，那么我将能够访问您的数据。

物理隔离是最强大的隔离形式。如果我们的应用程序在完全分开的物理机器上运行，那么我的代码无法访问您的应用程序的内存。

正如我们刚刚讨论的，内核负责管理其用户空间进程，包括为每个进程分配内存。由内核来确保一个应用程序无法访问分配给另一个应用程序的内存。如果内核管理内存的方式存在漏洞，攻击者可能利用该漏洞访问它们本不应能够接触到的内存。虽然内核经过了极其严格的测试，但它也非常庞大和复杂，并且仍在不断发展。即使在撰写本文时我们尚未发现内核隔离存在重大缺陷，我也不建议您赌注以后某个时候不会有人发现问题。

正如我们刚刚讨论的，内核负责管理其用户空间进程，包括为每个进程分配内存。由内核来确保一个应用程序无法访问分配给另一个应用程序的内存。如果内核管理内存的方式存在漏洞，攻击者可能利用该漏洞访问他们本不应能够接触到的内存。虽然内核经过了极其严格的测试，但它也非常庞大和复杂，并且仍在不断发展。即使在撰写本文时我们尚未发现内核隔离存在重大缺陷，但是未来任会有在内核发现漏洞的可能。

这些缺陷可能是由底层硬件的不断发展而产生的。近年来，CPU制造商开发了“ speculative processing”（猜测性处理），其中处理器在当前执行的指令之前运行，并在实际需要运行代码分支之前计算结果。这使得性能得到了显著提升，但也打开了著名的Spectre和Meltdown漏洞的大门。

读者可能想知道为什么人们认为VMM对虚拟机提供的隔离比内核对其进程提供的隔离更强大；毕竟，VMM也在管理内存和设备访问，并负责保持虚拟机的隔离。的确，虚拟机监视器的缺陷可能导致虚拟机之间的严重隔离问题。不同之处在于，虚拟机监视器的任务要简单得多。在内核中，用户空间进程允许为彼此提供一定的可见性；举一个非常简单的例子，我们可以运行`ps`命令，查看同一台机器上运行的进程。我们可以（在拥有正确权限的情况下）通过查看/proc目录中的信息访问有关这些进程的信息。我们可以通过IPC有意地在进程之间共享内存，以及共享内存。 所有这些机制合法地允许一个进程发现另一个进程的信息使隔离变得更弱，这是因为可能存在缺陷允许在意外或非预期的情况下进行这种访问。

在运行虚拟机时，没有类似的等价物；我们无法从一个虚拟机中看到另一个虚拟机的进程。管理内存所需的代码较少，主要是因为虚hypervisor不需要处理虚拟机可能共享内存的情况——这也不是虚拟机通常会做的事情。因此，hypervisor比完整内核要小得多且更简单。Linux内核有超过两千万行代码；相比之下，Xen虚拟机监控程序只有大约5万行。

在代码较少且复杂性较低的情况下，攻击面更小，可利用漏洞的可能性较低。因此，虚拟机被认为具有较强的隔离边界。 

尽管如此，虚拟机的攻击也并非没有发生过。Darshan Tank、Akshai Aggarwal和Nirbhay Chaubey描述了不同类型的攻击分类，国家标准与技术研究院（NIST）也发布了用于加固虚拟化环境的安全指南。

## 虚拟机的缺点

现在我们毫不怀疑虚拟机的隔离优势，那么人们为什么还要使用容器呢！ 与容器相比，虚拟机有以下缺点:

- 虚拟机的启动时间比容器长几个数量级。 毕竟，容器只是启动一个新的Linux进程，而不需要经历整个虚拟机的启动和初始化过程。相对较慢的虚拟机启动时间意味着它们在自动缩放方面效果较差，有些组织希望频繁发布新代码，甚至每天发布几次时，快速启动时间更为重要。 （然而，亚马逊的Firecracker，将在本文“Firecracker”章节中讨论，提供了启动非常快的虚拟机，按照目前的情况大约为100毫秒。）
- 容器为开发人员提供了方便的“一次构建，随处运行”的能力。 对于虚拟机，构建整个虚拟机镜像并在笔记本上运行是可能的，但非常缓慢，而且这种技术并没有像容器那样在开发者社区中广泛使用。
- 在今天的云环境中，租用虚拟机时必须指定其CPU和内存，并且无论实际上应用程序代码在其中运行使用了多少，我们都必须支付这些资源的费用。
- 每个虚拟机都有运行整个内核的开销。 通过共享内核，容器在资源使用和性能方面可以非常高效。

在选择使用虚拟机（VMs）还是容器时，需要在性能、价格、便利性、风险以及不同应用工作负载之间所需的安全边界强度等因素之间进行反复权衡。

## 容器隔离与虚拟机隔离的比较

正如在第4章中所阐述的，容器简单来说就是具有受限资源的Linux进程。它们通过命名空间、cgroups和更改根目录等机制由内核相互隔离。这些机制是专门为了在进程之间创建隔离而设计的。然而，容器共享内核的事实意味着基本隔离相对于虚拟机而言较弱。

然而，还有一些补救的措施！我们可以应用额外的安全功能和沙箱技术来加强这种隔离，这将在第8章中详细介绍。此外，还有一些非常有效的安全工具利用容器通常封装微服务的特性，这将在第13章中进行介绍。

## 总结

现在，应该对虚拟机有了很好的了解。我们应该已经了解了为什么与容器隔离相比，虚拟机之间的隔离被认为更强大，以及为什么容器通常在强硬的多租户环境中不被认为足够安全。理解这种差异在讨论容器安全时是一个重要的工具。

确保虚拟机本身的安全性超出了本书的范围，尽管我在第52页的“容器主机配置”中涉及了加固容器主机配置的内容。