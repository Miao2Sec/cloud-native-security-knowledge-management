# 容器安全威胁

近年来，容器应用呈现出爆炸性的增长趋势。尽管我们曾在 Docker 之前讨论过和容器相关的概念，但大多数人都认为，是 Docker 在 2013 年的首次露面，让开发者群体开始热衷于推广容器的使用。

使用容器的优势颇多，就如Docker的原始标语：`“一次构建，随处运行”`。这得益于容器将应用程序及其全部依赖项目捆绑在一起，并将应用程序与宿主机的其他部分进行隔离。这样每个应用程序都自带所需的所有依赖，并且可以方便地打包为容器镜像，在任何环境下都能运行。

这种隔离效应允许用户可以在一台主机上并行的运行不同的容器，且之间不会互相干扰。在容器没有出现之前，通常会遇到依赖性问题，如，两个应用程序需要同一个包的不同版本。就此问题而言，最简便的解决方案往往是在不同的机器上运行这些应用程序。而容器出现之后，所有的依赖都被隔离了，因此在一台服务器上运行多个应用程序变得非常简单。很快，人们发现可以利用这个特性，在一台主机（无论是虚拟机还是裸机服务器）上运行多个应用程序，而无需担心依赖关系问题。

基于此，下一步就是将容器化应用程序分布到服务器集群中。通过编排工具（如Kubernetes）可以自动执行这个过程，这样就不必在特定计算机上手动安装应用程序；只需要告诉编排工具要运行哪些容器，就会为每个容器寻找合适的位置。

从安全性的角度来看，容器化环境中的许多事项与传统部署中的许多事项是一样的。全世界都有一些攻击者想要盗取数据、更改系统的行为方式，或者利用他人的计算资源挖掘他们自己的加密货币。当你采用容器技术时，这些情况并不会变。然而，容器技术确实改变了应用程序的运行方式，因此存在一系列不同的风险。

## 风险、威胁和缓解措施

**"风险"**是指可能出现的问题以及这些问题出现时的影响。

"**威胁"**是指可能导致风险发生的因素。

**"缓解"**可以理解为对威胁的防范措施，也就是可以执行的行动，用以预防威胁或者至少降低其可能的成功率。

例如，一种可能的**风险**是你的汽车被被人开走，这可能是因为他们窃取了你房子里的汽车钥匙。**威胁**是他们可能以各种方式窃取钥匙：如溜进你的家里、在你不小心的时候偷走你得钥匙，甚至通过看似无害的方式如通过信箱或者其他方式。面对这些威胁，**缓解措施**则可能是你将车钥匙放在一个隐蔽的地方。

**风险**因组织而异。对于银行来说，可能最担心的风险是客户的钱被盗；对于搞电商的来说，他们担心欺诈交易的风险；运营个人博客网站的人可能会担心有人冒充他们和发布不适当的评论。另一方面，泄露客户个人数据的风险因地制宜，在大部分地区，风险主要是声誉上的，而在欧洲，根据GDPR法规，泄露客户个人数据的罚款最高可能达到公司总收入的4%。

由于**风险**的多样性，不同**威胁**的相对重要性也会有所不同，适合的**缓解措施**也会有所不同。风险管理框架是一种系统性的思考风险、列举可能的威胁、确定其重要性以及确定缓解方法的过程。

**威胁模型**则是一种识别并列举可能威胁系统的过程，通过系统地查看系统的组件和可能的攻击模式，威胁模型可以帮助确定系统最容易受到攻击的地方。

威胁模型并不是个一成不变的东西，因为它取决于每个使用个体、组织以及正在运行的应用程序等。

## 容器威胁模型

**构建威胁模型的一种方法是考虑所涉及的人员。这些可能包括:**

- 外部攻击者: 试图从外部访问的攻击者
- 内部攻击者：已设法访问的某些部分的内部人员
- 恶意的内部行为者：如开发人员和管理员，他们具有某种级别的权限来访问部署
- 不经意的内部行为者：他们可能会意外地导致问题
- 应用程序进程：对系统具有操作权限的应用进程

**每个人员都有需要考虑的特定权限集:**

- 他们的凭据有什么访问权限？ 例如，他们是否有权访问您部署运行主机上的用户帐户？

- 他们在系统上有什么权限？ 在Kubernetes中，这可以指每个用户以及匿名用户的基于角色的访问控制设置。

- 他们有什么网络访问？ 例如，系统的哪些部分包含在虚拟私有云（Vpc）中？

攻击容器有几种可能的途径，一种表示方法是考虑容器生命周期每个阶段的潜在攻击媒介，如图1-1。

![image-20240227145801598](https://gitee.com/xw1150/m2sec_image/raw/master/img/202402271458694.png)

**易受攻击的应用程序代码**

容器的生命周期从开发人员编写的应用程序代码开始，此代码及其依赖的第三方依赖项都可能包含漏洞。 避免运行具有已知漏洞的容器的最佳方法是扫镜像扫描，详情可见第七章。 镜像扫描不是一次性的，因为更新的代码中总有新的漏洞。扫描过程还需要确定容器运行过期软件包是时间， 一些扫描器还可以识别已嵌入到镜像中的恶意软件。

**严重混淆的容器镜像**

代码编写完成后，下一步是将其构建到容器镜像中。 当进行构建容器镜像的配置时 ，有很多攻击的手段可以在该过程中被引入。如容器以root用户身份运行时，其在主机上拥有比实际需要更多的特权，详情见第六章。

**来自于构建镜像时攻击**

如果攻击者可以修改或影响容器镜像的构建方式，则可以轻而易举的插入恶意代码，这些代码以后在生产环境中运行时，是一个不小的威胁。这部分内容详情也在第六章。

**供应链攻击**

容器镜像构建成功后，将会被存储在镜像仓库中，并在运行该镜像时从镜像仓库中检索或"拉取"该镜像。 但是你怎么知道你拉的镜像和你之前推送的完全一样？ 攻击者可以在构建和部署之间替换镜像或修改镜像够在上面植入恶意代码，详情同见第六章。

**不安全的配置**

容器支持以配置文件来启动，这些配置可能为容器提供了不必要的特权。 而且，大多数人直接从互联网上下载YAML配置文件来运行，如果不对其进行安全检查就运行是一种十分危险的行为。本种场景将在第四章中详细讨论。

**敏感信息泄露**

应用程序代码通常需要凭据、令牌或密码，以便与系统中的其他组件通信。 在容器化部署中，怎么样能够将这些敏感的信息值递到容器化的代码中是值得考虑的问题。 十二章中介绍了不同的方法来实现这一点。

**不安全的网络**

容器通常需要与其他容器或与外部世界进行通信。  第10章讨论了容器中的网络，第11章讨论了如何在组件之间设置安全的网络连接。

**容器逃逸漏洞**

一些广泛使用的容器运行时，包括containerd和CRI-O等现在已经非常安全，但仍有可能存在尚未发现的漏洞，这些漏洞会让容器内运行的恶意代码逃到主机上。 这种问题被称为容器逃逸。 在第4章中会介绍防止容器逃逸的措施。 鉴于某些应用，逃逸的后果可能会造成十分严重的损害，需要考虑更强大的隔离机制，在第8章中介绍。

## 安全边界

安全边界（有时称为信任边界）的概念，会出现在系统的各个部分之间，用户通常需要一些不同的权限集才能在这些部分之间移动。 有时这些边界是以管理方式设置的。例如：在Linux系统中，系统管理员可以修改安全边界-通过更改用户所属的组来定义用户可以访问哪些文件。

容器同样可以视为安全边界。 应用程序代码在容器内运行，它不应该能够访问容器外部的代码或数据，除非它明确地被授予这样做的权限（例如，通过挂载到容器中的卷）。

攻击者与攻击目标之间的安全边界越多，就越难达到目的。上文中"**容器威胁模型**"中描述的攻击媒介可以链接在一起以突破多个安全边界。 例如:

攻击者可能会发现，依靠应用程序的依赖的漏洞能够在容器内达到远程代码执行的目的。

- 假设被破坏的容器没有直接访问任何有价值的数据。 攻击者需要找到一种方法来逃出容器，要么移到另一个容器上，要么移到主机上。 容器逃逸漏洞是一个手段、不安全配置也可能提供逃逸的方法。而且如果攻击者发现这些方法中的任何一个可用，则可以逃逸到宿主机上。
- 下一步是寻找在主机上获得root权限的方法。 通常情况下，应用程序代码在容器中以root身份运行，这一步轻而易举，像第4章中看到的那样。
- 利用主机上的root权限，攻击者可以访问主机或该主机上运行的任何容器可以访问的任何内容。

在部署中加强安全边界的管控将使攻击者的入侵更加困难。

威胁模型的一个重要方面是考虑从运行应用程序的环境中进行攻击的可能性。在云部署中，您可能与其他用户及其应用程序共享一些资源。 共享机器资源称为多租户，它在威胁模型中一个重要的因素。

## 多租户

在多租户环境中，不同的用户在 共享的硬件上运行其各自的工作负载。根据这些工作负载的所有者以及不同租户之间的相互信任程度，你可能需要在它们之间设置更强的边界，以防止它们互相干扰。

多租户是自20世纪60年代大型机时代以来一直存在的概念，当时客户在共享机器上租用CPU、内存和存储空间。 这与今天的公共云（如Amazon AWS，Microsoft Azure和Google Cloud Platform）没有太大的不同，客户租用CPU时间、内存和存储以及其他功能和托管服务。 自从Amazon AWS在2006年推出EC2以来，租户已经能够租用在全球数据中心的服务器架上运行的虚拟机实例。 

### 共享机器

在某些情况下，单个Linux机器（或虚拟机）可能被许多用户共享。 在这种环境中，Linux访问控制用于严格限制用户访问。 每个用户都有自己的登录ID，Linux的访问控制用于限制访问，以确保用户只能修改自己目录中的文件。

正如您将在第4章中看到的，在同一主机上运行的所有容器共享相同的内核。 如果机器正在运行Docker守护程序，则任何可以有效发出docker命令的用户都具有root访问权限，因此系统管理员不会希望将其授予不受信任的用户。

在企业环境中，更具体地说，在云原生环境中，您不太可能看到这种共享机器。 相反，用户（或相互信任的用户团队）通常会使用以虚拟机形式分配给他们的自己的资源。

### 虚拟化

一般来说，虚拟机被认为是一种强隔离，即邻居不太可能观察或干扰我们在虚拟机中的活动。 在第5章中介绍了更多关于这个隔离是如何实现的。事实上根据公认的定义虚拟化根本不算作多租户，多租户是指不同群体共享同一软件的单个实例，而在虚拟化中用户无权访问管理其虚拟机。

但是，这并不是说虚拟机之间的隔离是完美的，一些用户抱怨**"吵闹的邻居"**问题，因为与其他用户共享一台物理机器会导致性能出现意想不到的情况。 

还有一些软件漏洞可能危及虚拟机之间的边界。

对于某些应用程序和某些组织（特别是政府、金融或医疗保健），隔离漏洞造成的后果可能非常严重，所以需要保证绝对的物理分离。 这就可以在私有云上，在自己的数据中心运行或由服务提供商代表这些组织去管理，以确保工作负载的完全隔离。 私有云有时会附带额外的安全功能，例如对有权访问数据中心的人员进行额外的背景检查。

许多云提供商都有VM选项，保证用户是物理机器上唯一的顾客，也可以租用云提供商运营的裸机。 在这两种情况下，我们完全避免嘈杂的邻居问题，并且还具有物理机器之间更强的安全隔离的优势。

无论是在云中租用物理或虚拟机，还是使用自己的服务器，如果需要运行容器，就可能需要考虑多个用户组之间的安全绑定。

### 容器多租户

容器之间的隔离不如虚拟机（VM）之间的隔离强。 虽然它确实取决于具体的风险状况，但我们绝对不太可能希望在同一台机器上使用容器的其他用户是一个危险份子。

即使在计算机上运行的所有容器都由绝对信任的人运行，我们可能希望通过确保容器之前不会相互干扰而导致一系列的问题。

在Kubernetes中，我们可以使用命名空间来细分机器集群，供不同的个人、团队或应用程序使用。

"命名空间"一词是一个重载术语。 在Kubernetes中，命名空间是一种高级抽象，它细分了集群资源，这些资源可以应用不同的Kubernetes访问控制。 在Linux中，命名空间是一种低级机制，用于隔离进程意识到的机器资源。 

使用基于角色的访问控制（RBAC）来限制可以访问这些不同Kubernetes命名空间的人员和组件。 如何做到这一点的细节不在本书的范围之内，但我想提一下，Kubernetes RBAC只控制您可以通过Kubernetes API执行的操作。 应用程序恰好在同一主机上运行的Kubernetes pod中的容器仅通过容器隔离来相互隔离，如本书所述，即使它们位于不同的命名空间。 如果攻击者可以将容器逃逸到主机，那么Kubernetes命名空间边界对他们影响其他容器的能力没有任何区别。

### 容器实例

Amazon AWS、Microsoft Azure或Google Cloud Platform等云服务提供了许多托管服务，用户可以通过这些服务租用软件、存储和其他组件，而无需安装或管理它们。 一个典型的例子是亚马逊的关系数据库服务（RDS）;有了RDS，您可以轻松地配置使用PostgreSQL等知名软件的数据库，并且备份数据就像勾选一个盒子一样简单

当然托管服务也已扩展到容器世界。 Azure容器实例和AWS Fargate是允许您运行容器而无需担心它们运行的底层机器（或虚拟机）的服务。

这可以使用户免于重大的管理负担，并可以轻松地随意扩展部署。 但是，至少在理论上，您的容器实例可以与其他客户的实例托管在同一虚拟机上。 如果有疑问，请与您的云提供商联系。

截止到目前，如果您已经意识到您的部署的大量潜在威胁。 在深入研究本书的其余部分之前，我想介绍一些基本的安全原则，这些原则应该指导您在评估需要在部署中引入哪些安全工具和流程时的思考。

## 安全原则

### 最低特权

最小特权原则规定：一个用户应该只能访问他/她为完成任务所需要的信息和资源，而不能访问更多的信息。 例如，如果您有一个在电子商务应用程序中执行产品搜索的微服务，则最小特权原则建议该微服务应仅具有授予其对产品数据库的只读访问权限的凭证。 它不应该具有访问权限：比如用户或支付信息，也不应该具有修改产品信息的写权限。

### 深度防御

有许多不同的方法可以提高部署及其中运行的应用程序的安全性。 深入防御的原则告诉我们，应该设置多级保护层。 如果攻击者能够破坏一个防御，另一层能够防止攻击者继续进行破坏行为。

### 减少攻击面

作为一般规则，系统越复杂，暴露的攻击面就越多，就越有可能遭受到攻击。 消除复杂性可以使系统更难攻击。 这包括:

- 尽可能保持接口小而简单，从而减少接入点
- 限制可以访问服务的用户和组件
- 最大限度地减少代码量

### 限制影响半径

将安全控制分段为较小的子组件或"单元"。这种概念意味着如果发生最坏的情况，影响是有限的。 容器非常适合这一原则，因为通过将体系结构划分为微服务的许多实例，容器本身可以充当安全边界。

### 职责分离

与最小特权和限制影响半径有关的是职责分离。将不同的职责进行分离，不同的组件或人员只在他们需要的整个系统的最小子集上被赋予权限。 这种方法通过确保某些决定需要多个用户的权限来限制单个特权用户可能造成的损害。

### 将安全原则应用于容器

正如您将在本书后面的章节中看到的，容器的粒度可以帮助我们应用所有这些安全原则。

**最低特权**

通过为不同的容器提供不同的权限集，每个权限集最小化为实现其功能所需的最小权限集。

**深度防御**

容器提供了另一个可以强制执行安全保护的边界。

**减少攻击面**

将整体拆分为简单的微服务可以在它们之间创建简洁的接口，如果精心设计，可以降低复杂性，从而限制攻击面。 有一个相反的论点是添加一个复杂的编排层来协调容器会引入另一个攻击面。

**限制影响半径**

如果容器化应用程序受到威胁，安全控制可以帮助控制容器内的攻击并防止其影响系统的其余部分。

**职责分离**

权限和凭据只能传递到需要它们的容器中，因此一组密钥的妥协并不一定意味着所有密钥都丢失。

这些安全实践听起来不错，但有点理论化。 在实践中，这些安全实践很容易被糟糕的系统配置、糟糕的容器镜像环境或不安全的操作所抵消。 在本书的最后，您应该该做好准备，以避免容器化部署中可能出现的安全陷阱，并充分利用这些实践
