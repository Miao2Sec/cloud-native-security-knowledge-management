# 第七章：镜像中的软件漏洞

长期以来，修补软件漏洞一直是确保代码安全性的重要措施。在容器时代，这个问题仍然严峻，但在本章中，我们将看到漏洞修补路径已经更新迭代。我们先了解一下什么是软件漏洞，以及它们是如何发布和追踪的。

## 漏洞研究

漏洞是软件中的已知缺陷，可被黑客利用进行恶意活动。通常来说，软件越复杂，就越容易存在缺陷，其被黑客攻击的风险也就越大。常用软件中只要存在漏洞，就会让黑客有机可乘，所以现在整个行业都在致力于发现和公开新漏洞，尤其是隐藏在操作系统包和语言库中的漏洞。例如大家可能听说过的一些高破坏性漏洞：Shellshock、Meltdown和Heartbleed，都是漏洞研究的成果。它们不仅有名字还有自己的专属logo。这些都是知名度很高的漏洞，但其数量只占每年公布的数以千计漏洞问题的极小一部分。

一旦发现漏洞，修复程序会迅速发布，以便软件用户能在黑客利用之前修补漏洞。为了防止黑客攻击新漏洞，研究人员提出了“安全披露责任制”这一概念。安全研究人员发现漏洞后会与软件开发人员或供应商联系，在双方约定的时间后才公布漏洞细节。这种协作能促使供应商尽快提供修复程序，从而保障用户安全。

新漏洞的名称开头会被标记上一串独特的标识符“CVE”，代表“常见漏洞”，符号后跟年份。比如，ShellShock漏洞是在2014年发现的，官方标识为CVE-2014-6271。MITRE组织负责管理这些标识符，他们监督着多个CVE编号机构（CNAs），这些机构授权为特定软件分配CVE ID。一些大型软件供应商，如Microsoft、Red Hat和Oracle，都是有权为其产品分配CVE ID的CNAs。2019年底，GitHub也成为了CNA。

这些CVE标识符收录于美国漏洞数据库（NVD），以追踪受其影响的软件包和版本。乍一看，你可能会想，这个数据库里既然包含了所有会受影响的软件包和版本，那我只要对照数据库查漏补缺就行了。但事情并没那么简单，因为根据用户使用情况而发行的Linux版本，可能也会包含漏洞修复程序。

### 漏洞、修复和发行版

以ShellShock漏洞为例，这是一个严重的GNU Bash包漏洞，NVD页面列出了一系列受影响的版本，从1.14.0到4.3不等。如果你在旧版Ubuntu 12.04上使用bash版本4.2-2Ubuntu 2.2，或许会误以为该系统容易受攻击，因为它包含在NVD的易受攻击列表内。

然而，据Ubuntu的安全公告显示，该版本已应用了漏洞修复程序，因此并不易受攻击。Ubuntu维护者选择为漏洞提供补丁而非强制用户升级到新的bash次要版本。

要确定系统中安装的软件包是否易受攻击，除了参考NVD，还需查看相应发行版发布的安全建议。

目前，我们讨论了通过包管理器（如apt、yum、rpm或apk）以二进制形式分发的软件包。然而，共享这些包仍会有一些问题，如不同应用程序可能对不同版本的包产生依赖，从而导致兼容性问题。而容器则通过为每个容器提供独立的根文件系统解决了这一问题。

### 应用程序级漏洞

在应用程序层面也有漏洞风险。很多应用程序都会使用第三方库，而这些库通常通过特定的语言包管理器如Node.js的npm、Python的pip、Java的Maven等来进行安装。这些工具安装的第三方软件包可能会成为潜在的漏洞源。
在使用Go、C、Rust等编译语言时，您的第三方依赖可以安装为共享库，也可以在构建时链接到二进制文件中。
所谓独立可执行文件（即“standalone”），是指不依赖外部的二进制文件。尽管可能依赖第三方库或包，但这些依赖已经内置在可执行文件里。在这种情况下，您可以选择基于空白基本镜像创建容器镜像，其中只包含您的二进制可执行文件。
如果应用程序没有任何依赖项，则无法扫描其已发布的包是否存在漏洞。尽管如此，仍可能存在使其易受攻击者攻击的缺陷，这便是我们所谓的“0day漏洞”。

## 漏洞风险管理

漏洞管理是风险管理中至关重要的一环。几乎所有部署的重要软件都可能存在一些漏洞，对系统被攻击构成风险。要有效管理这些风险，您需要能够识别漏洞、评估严重程度、确定优先级，并建立相应的修复或缓解流程。
漏洞扫描器能够自动检测漏洞。它们提供了关于每个问题严重性的信息，以及应用修复程序的软件包版本（若可用）。

### 漏洞扫描

在互联网上有许多基于不同技术的漏洞扫描工具，包括nmap和nessus等端口扫描工具，试图通过从外部检测实时运行系统中的漏洞。这种方式很有价值，但并非我们在本章讨论的重点。我们更关注的是通过检查安装在根文件系统中的软件来帮助您找到漏洞的工具。
要确定漏洞，首要任务是确定安装了哪些软件。软件的安装可能是通过Linux发行版的根文件系统，可能存在Linux包管理器（如rpm或apk）安装的系统包，以及特定语言的包管理工具如pip或RubyGems安装的包，甚至可能是直接使用wget、curl或FTP手动安装的软件。
一些漏洞扫描器会查询包管理器获取已安装软件列表。因此，如果使用这些工具之一，建议避免直接手动安装软件，以确保软件被扫描到漏洞。

### 已安装软件包

如第六章所述，每个容器镜像都可能包含Linux发行版和安装的软件包及应用程序代码。每个容器镜像都可能有多个正在运行的实例，每个实例都有自己的容器镜像文件系统副本，其中可能存在易受攻击的包。如图7-1所示，图中展示了两个容器X实例和一个容器Y实例，同时也展示了直接安装在主机上的一些软件包。

![](https://gitee.com/xw1150/m2sec_image/raw/master/img/20240301215608.png)

<div align="center">
图7-1.主机和容器中的软件包
</div>

直接将软件包安装到主机并不罕见—— 事实上，出于安全原因，系统管理员通常需要修补这些软件包。传统上，这是通过SSH连接到每台主机并安装补丁包来实现的。然而，在云原生时代，这种方法不被认可，因为手动修改机器状态的方式意味着无法自动重新创建相同状态的机器。因此，最好的方式是构建一个新的机器镜像，或更新用于生成镜像的自动化脚本，以包含更新的软件包。

### 容器镜像扫描

要确定部署中是否存在运行易受攻击软件的容器，需要扫描这些容器中的所有依赖项。有多种方法可以实现这一点。
假设有一种工具可以扫描每个正在运行的容器（或跨多台主机的部署）。在云原生部署中，通常会从同一个容器镜像启动数百个容器实例，因此采用这种方法会非常低效，因为会重复查看数百个相同的依赖关系。相比之下，扫描生成容器的容器镜像要更有效率。
然而，这种方法要求容器只运行容器镜像中的软件，而不运行其他再安装的软件。每个容器中运行的代码必须是不可变的。接下来我们将看看将容器视为不可变的原因。

这里是历史讨论的总结，作为前情提要：讨论了应用程序级漏洞的风险，包括第三方库的漏洞可能性和独立可执行文件的安全性。强调了漏洞管理的重要性，并提到了漏洞扫描工具的作用以及扫描方法。此外，还介绍了容器镜像扫描的概念，以及扫描生成容器镜像的有效性。

### 不可变容器

（通常情况下），容器一旦开始运行，就可能会不受限制地下载额外软件到其文件系统中。在容器的早期阶段，这种做法曾相当普遍，视为一种通过更新软件版本而无需重新构建容器镜像的方法。但是这被认为是一个非常糟糕的做法，原因有几个，包括：

1. 如果容器在运行时下载代码，不同实例的容器可能会运行不同版本的代码，但很难辨别哪个实例运行的是哪个版本。若没有存储代码版本，要重建相同副本将变得异常困难，尤其在复现现场问题时。这里也可能出现容器漂移，带来数据、代码丢失问题。
2. 若软件可随时随地下载，那么控制并确保每个容器中运行的软件的来源将变得更加困难。
3. 在CI/CD管道中，构建容器镜像并将其储存在仓库中，可以轻松实现自动化。在同一管道中添加额外的安全检查也变得容易，例如漏洞扫描或软件供应链验证。
   许多生产环境将容器视为不可变的，尽管这只是一种最佳实践而非强制性规定。若扫描镜像时发现可执行文件不在镜像内，某些工具可通过阻止在容器中运行该可执行文件，自动强制实施容器不变性。这便是所谓的漂移预防，将在第13章作进一步探讨。
   另一种实现不变性的方法是运行容器时使用只读文件系统。若应用程序代码需访问可写本地存储，可以挂载可写临时文件系统。这可能需要修改应用程序，以仅将数据写入该临时文件系统。
   将容器视为不可变的，您只需扫描每个镜像，即可发现所有容器中可能存在的漏洞。然而，仅在特定时点进行扫描可能不够。让我们思考为何定期扫描必要。

### 常规扫描

正如本章一开始所讨论，全球各地的许多安全研究人员正在发现现有代码中以前未知的漏洞。有时候，他们会发现存在多年的问题。其中一个最著名的例子是HeartBleed漏洞，它是在广泛使用的OpenSSL包中发现的关键漏洞。该漏洞利用保持TLS连接活动的心跳请求和响应流中的问题。被发现于2014年4月，这个漏洞允许攻击者发送特定心跳请求，要求提供较少数据以填充响应缓冲区的剩余部分。由于OpenSSL代码未进行长度检查，导致响应返回敏感数据，泄漏给攻击者。此漏洞后来被追溯为涉及密码、社会安全号码和医疗记录泄漏的一场严重数据事件。
类似HeartBleed这样严重的事件很罕见，但如果您使用第三方依赖项，随时可能发现新漏洞是有意义的。遗憾的是，我们无法预知其何时发生。即使您的代码未更改，依赖项中出现新漏洞的可能性仍然存在。
定期重新扫描容器镜像使扫描工具能根据其对漏洞的最新认识（源自NVD和其他安全资讯来源）进行检查。作为自动化CI/CD管道的组成部分，除了在构建新镜像时扫描之外，定期重新扫描所有已部署镜像（通常每24小时）是一种常见做法。

### 扫描工具

目前市面上有许多用于扫描容器镜像的工具，涵盖了从开源工具如Trivy、Clair和Anchore，到商业解决方案如JFrog、Palo Alto和Aqua等公司的产品。除此之外，许多容器镜像注册解决方案，例如Docker Trusted Registry和CNCF项目Harbor，以及主要公共云提供商的仓库，都已将扫描功能嵌入其平台。
值得一提的是，不同扫描工具所得出的扫描结果可能存在显著差异，这一点值得深思。

### 信息来源

正如前文所述，漏洞信息可以来自多个渠道，包括每个发行版的安全建议。举例来说，Red Hat有不止一个渠道——其OVAL feed只包含已修复的漏洞，而非尚未修复的漏洞。
使用扫描工具时，确保其不仅仅依赖底层NVD数据，还能包含来自各个发行版的安全建议数据，以免导致基于特定发行版的镜像出现大量误报。若您使用特定Linux发行版或像distroless这样的解决方案，务必确保您的扫描工具支持这些镜像类型。

### 信息来源更新滞后

有时，发行版维护者可能会更改漏洞报告方式。举例而言，最近Alpine曾停止更新alpine-secdb feed，转而采用aports的新系统。然而，仍有一些扫描工具在报告中仅使用了过时的Alpine feed 数据，而这个feed已经数月未更新。

### 未修复漏洞

有时候，发行版维护者可能决定不修复某些特定漏洞（可能因为风险可以忽略，修复成本过高，或者因为维护者认为在其平台上该漏洞无利用价值）。
针对这种情况，扫描工具开发人员需要思考一个哲学问题：鉴于漏洞不可操作，是否应该在扫描结果中显示该漏洞？在Aqua，我们接到了一些客户的反馈，他们不希望看到这类结果，因此我们为用户提供了选择。这凸显了在漏洞扫描领域，没有所谓“正确”的结果。这里涉及扫描结果降噪，我们会再后面重新开个坑来聊下容器镜像漏洞扫描降噪，敬请期待。

### 子包漏洞

有时候，一个软件包由包管理器安装并报告，但实际上它包含一个或多个子包。以Ubuntu上的bind软件包为例。有时候，bind可能只是与doc子包一起安装，而doc子包只包含文档。有些扫描程序可能假设如果软件包被安装报告，那么整个软件包（包括所有可能的子包）都已安装。这可能导致误报，即扫描程序报告不存在的漏洞，因为关键的子包未被安装。

### 软件包名称不同

软件包的源名称可能包含完全不同的二进制文件。例如，在Debian中，shadow软件包包含名为login、passwd和uidmap的二进制文件。若扫描工具未考虑到这一点，可能导致漏洞漏报。

### 额外扫描功能

除了检测漏洞外，一些镜像扫描器还可以检测其他问题，例如：

- 镜像中的已知恶意软件
- 含有setuid位的可执行文件（可导致权限提升，如在第2章中介绍的）
- 配置为以root用户运行的镜像
- 包含秘密凭证，如令牌或密码
- 存在信用卡信息或社会安全号码等敏感数据

### 扫描工具错误

正如本书中所阐述的，报告漏洞并不像最初想象的那样简单。因此，使用任何扫描工具时，很可能会因扫描器内部错误或者读取的安全建议数据有缺陷而导致误报或漏报。
总体而言，拥有扫描工具总比没有好。若您经常使用扫描工具，您将更好地了解您的软件是否容易受到攻击。举例来说，Shellshock漏洞并非是最近才被发现的，而是数十年前的代码遗漏。若您依赖于复杂的依赖项，需预料在某个时刻可能发现其中的漏洞。
误报虽然会让人不爽，但某些工具可以让您将单个漏洞报告列入白名单，这样您就可以自行决定是否接受它们。假设您确信将漏洞扫描工具纳入您团队的工作流程是明智之举，接下来让我们探讨将其整合到您团队的CI/CD管道中的可能选择。
在CI/CD管道中加入漏洞扫描，从左到右依次考虑，“编写代码”位于最左侧，“部署到生产”在最右侧，就如同图示7-2中所示。尽早在管道中解决问题是最佳选择，因为这样做更快速、更经济，就像在部署后发现和修复错误比在开发阶段花费的时间和成本更大一样。
在传统基于主机的部署中，共享同一软件包的所有运行在主机上的软件需要定期由安全团队进行安全补丁更新。这一活动通常与每个应用程序的生命周期的开发和测试阶段分开，位于部署管道的右侧。常常会遇到这样的问题：不同应用程序共享同一软件包，但需要不同版本，这就需要仔细管理依赖关系，有时还需要修改代码。
相比之下，正如您在第6章中所见，基于容器的部署中，每个镜像都包含自己的依赖项，这使得不同的应用程序容器可以拥有各自所需的每个软件包的特定版本。不再需要担心应用程序代码与其依赖项集之间的兼容性。
基于此，再加上容器镜像扫描工具的出现，使得漏洞管理可以在管道中“左移”。团队可以将漏洞扫描作为自动化步骤。当需要解决漏洞时，开发人员可以通过更新和重建他们的应用程序容器镜像来包含修补版本，不再需要安全团队手动进行此工作。
扫描可以在几个环节引入，如图示7-2所示：
![](https://gitee.com/xw1150/m2sec_image/raw/master/img/20240301215812.png)
<div align="center">
图7-2.扫描CI/CD管道中的漏洞
</div>

### 开发阶段扫描：

如果使用易于在桌面上部署的扫描器，个人开发人员可以扫描他们在本地镜像构建中的问题，以便在推送到源代码存储库之前修复问题。现在商业或者开源的扫描工具都会有开发IDE的插件工具，可以在IDE上直接进行漏洞扫描，如图7.3展示的漏扫插件，当然这个插件一般是需要配置服务端的。
![](https://gitee.com/xw1150/m2sec_image/raw/master/img/20240303134521.png)

<div align="center">
图7-3.IDEA中的代码扫描插件
</div>

### 构建阶段扫描：

考虑在构建容器镜像后立即包含扫描步骤。如果扫描发现了高危漏洞，您可以让构建失败，以确保其永不被部署。图示7-4展示了AWS CodeBuild项目输出的示例，该项目从Docker文件构建镜像并进行扫描。在本例中，发现一个高危漏洞导致构建失败。如果识别到系统层的漏洞后也可以使用一些自动化镜像进行修复，推荐[copacetic](https://github.com/project-copacetic/copacetic)
![](https://gitee.com/xw1150/m2sec_image/raw/master/img/20240301215827.png)，可以自动化的修复镜像漏洞，这个后面也会开个坑去聊。

<div align="center">
图7-4.扫描到高危漏洞时的失败构建案例
</div>

### 入库后扫描：

在构建镜像后，通常会将其推送到镜像仓库。定期扫描镜像是个不错的主意，以防止出现长时间未重建镜像中出现新漏洞的情况。

> 以下文章详细阐述了如何在不同的CI/CD解决方案中整合各种扫描器：

> [Scanning images with Trivy in an AWS CodePipeline](https://aws.amazon.com/jp/blogs/containers/scanning-images-with-trivy-in-an-aws-codepipeline/?nc1=h_ls)

> [Container Scanning on GitLab](https://docs.gitlab.com/ee/user/application_security/container_scanning/)

> [Docker Image Scanning in your Codefresh Pipeline with Aqua](https://www.aquasec.com/blog/docker-security-image-scanning-codefresh/)

您可能不想把扫描步骤留到部署点，这是因为在容器实例化时必须要扫描每个实例，即使这些实例来自同一容器镜像。如果您视容器为不可变的，那么您应该扫描镜像而不是容器。
确保不会部署易受攻击的镜像同样重要，这可以作为我们在“准入控制”中讨论的措施之一，正如图示7-2所示。如果没有检查来确保只能部署经扫描的镜像，绕过漏洞扫描器将更为容易。

一般来说，商业漏洞扫描器是作为更广泛平台的一部分出售的，该平台将准入控制与扫描结果相关联。在Kubernetes部署中，您可以使用Open Policy Agent实施自定义准入控制检查，其中可能包括检查镜像是否经过漏洞扫描。作为Kritisproject的一部分，谷歌也在研究这一功能。

迄今为止，在本章中，我们已经讨论了应用程序所依赖的依赖项中的已知漏洞。然而，我们不应忽视一个重要的漏洞类型，即“0day漏洞”。

### 0day漏洞

本章开头讨论了世界各地的安全研究人员如何寻找利用现有软件的新方法。显而易见的是，发现新漏洞后，需要一段时间才能发布修复程序。在修复程序发布之前的这段时间里，该漏洞被称为0day漏洞。（如果30天内能应用上安全补丁，一般用户都是愿意等的，但在这短短的30天内黑客仍然可能会多次尝试攻击软件，着实让人头疼。）

如果第三方库中存在攻击者可以利用的漏洞，那么任何代码都有可能受到影响——包括您的团队正在开发的应用程序。虽然同行审查、静态分析和测试有助于发现代码中的安全问题，但有些问题可能被忽略。取决于您的组织和数据的价值，恶意人士可能会有动机去寻找这些漏洞。

好消息是，如果一个漏洞还未被公开，那么世上大部分潜在攻击者都不知道它的存在，就像您也不知道一样。

坏消息是，您可以相信，熟练的黑客和国家组织可能秘密掌握着未公开的漏洞。我们从爱德华·斯诺登的披露中知道这一点。

匹配漏洞数据库的信息也无法识别尚未公开的漏洞。根据漏洞利用的类型和严重程度，第8章中介绍的沙盒可能是保护应用程序和数据的有效方法。最大的防范0day的希望在于及时检测和防止异常行为，这将在第13章中讨论。

## 总结：

本章带您了解了漏洞研究以及分配给不同漏洞的CVE标识符，意识到为什么具有特定发行版的安全建议信息非常重要，而不仅仅依赖于NVD。您也明白了为何不同的扫描工具会产生不同的结果，因此能够更好地选择适合的工具。无论您选择哪种扫描工具，希望您现在能确信您需要将容器镜像扫描融入您的CI/CD管道中。
